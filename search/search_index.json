{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Microservices with Docker, Kubernetes, RabitMQ, PDF Converter","text":"<p>This course material is tailored for my Kubernettes and Docker . It covers the fundamentals of Kubernetes and Docker, along with a practical guide to building a PDF converter microservice. This tutorial is designed to help you understand containerization, orchestration, and microservice architecture through hands-on examples.</p>"},{"location":"#about-me","title":"About Me:","text":"<p> My name is Daniel Okot. I am a software engineer. For about 3 years, I have been building software and i share my experience at my Youtube channel where I educate people about programming mainly using the Python language. I have worked on freelance, and fulltime roles. I have a passion for educating others and sharing knowledge. When am not coding am sleeping.</p> <p>If you enjoy this content, please consider subscribing to my YouTube channel for more tutorials and updates. Your support helps me create more valuable resources for the community. Don't forget to like, share, and comment to help others discover this content!</p>"},{"location":"#follow-me-on-the-following-platforms","title":"Follow me on the following platforms","text":"<ul> <li>Twitter</li> <li>Github</li> <li>Youtube</li> </ul>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#introduction","title":"Introduction","text":"<p>This application will be a fully-fledged PDF converter, enabling users to convert various documents into PDF format. It operates on a diverse technology stack, which will be detailed below. First, let's explore the stack that powers this application and the rationale behind our choices. We have: MongoDB and PostgreSQL as our database providers. Django and FastAPI to power the different services within the application. Next.js on the frontend, facilitating the upload of documents and the retrieval of converted PDFs. RabbitMQ as a notification service and runtime broker.</p>"},{"location":"getting_started/#why-we-chose-this-stack","title":"Why We Chose This Stack","text":"<p>At first glance, one might question the need for such a complex configuration for a seemingly simple task like PDF conversion. This is a valid point. However, the answer lies in the benefits of scalability, flexibility, and maintainability that this stack provides. Using a combination of Django and FastAPI allows us to leverage the strengths of both frameworks: Django for its robust features and FastAPI for its speed and efficiency in handling asynchronous requests. The choice of MongoDB and PostgreSQL offers us the flexibility to manage different types of data effectively. Moreover, Next.js enhances the user experience by providing a seamless interface for document uploads and conversions. Finally, RabbitMQ ensures that our application can handle notifications and background tasks efficiently, making it more responsive and reliable. In summary, while the core functionality may seem straightforward, the chosen stack supports a scalable and efficient application that can grow and adapt to future needs.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#1-installation-and-project-setup","title":"1. Installation and Project SetUp","text":"<p>In this chapter, we install FastAPI, starting with a minimal setup.</p>"},{"location":"installation/#1-virtual-environment-creation","title":"1. Virtual Environment Creation","text":"<p>Lets begin by creating a virtual environment using the built-in Python module <code>venv</code>. If you already have Python installed, you might not need to install it separately. However, on Linux, installation may be necessary based on your distribution. In your commandline or terminal, type the following command.</p> <pre><code>python3 -m venv env\n</code></pre> <p>This command generates a virtual environment in the specified folder (in our example, <code>env</code>). This folder is an isolated Python environment that separates the dependencies of our project from the system-wide Python installation.</p> <p>Activate the virtual environment using the following commands:</p> <p>On Linux or macOS:</p> <pre><code>source env/bin/activate\n</code></pre> <p>On Windows:</p> <pre><code>env\\Scripts\\activate\n</code></pre> <p>Once activated, your command line will indicate the active virtual environment:</p> <p>On Linux or macOS:</p> <pre><code>(env) yourusername@yourmachine$\n</code></pre> <p>On Windows:</p> <pre><code>(env) C:\\users\\YourUsername&gt;\n</code></pre>"},{"location":"installation/#2-directory-structure","title":"2. Directory Structure","text":"<p>At this point, your directory structure should look like this:</p> <pre><code>\u2514\u2500\u2500 env\n</code></pre>"},{"location":"installation/#3-installing-fastapi","title":"3. Installing FastAPI","text":"<p>Now, let us install FastAPI within the virtual environment. We shall install FastAPI using <code>pip</code> with the following command.</p> <pre><code>(env) pip install \"fastapi[standard]\"\n</code></pre>"},{"location":"installation/#4-freeze-dependencies","title":"4. Freeze Dependencies","text":"<p>Freeze the installed dependencies into a <code>requirements.txt</code> file to track the exact versions of our dependencies so that we can easily reproduce them in the future.</p> <pre><code>(env) pip freeze &gt; requirements.txt\n</code></pre>"},{"location":"installation/#5-confirm-the-installation","title":"5. Confirm the installation","text":"<p>Let us confirm our FastAPI installation by running the following command.</p> <pre><code>(env) fastapi --version\nFastAPI CLI version: 0.0.2\n</code></pre> <p>This command will show us the version of the FastAPI CLI\u2014the FastAPI command-line interface. The <code>fastapi</code> command shall help us run and manage our app as we shall see in the coming chapters.</p> <p>If the version has been displayed, then we are sure that FastAPI has been installed in our virtual environment.</p>"},{"location":"installation/#conclusion","title":"Conclusion","text":"<p>By following these steps, you have successfully set up a virtual environment, and installed FastAPI, frozen the dependencies to reproduce the project in the future and you have verified your installation using the <code>fastapi</code> CLI command. This structured approach ensures a clean and manageable development environment for our FastAPI project. Next, we shall create a simple web server and create our first API routes.</p>"},{"location":"installation/#2-io-and-project-setup","title":"2. Io and Project SetUp","text":"<p>njnkn</p>"},{"location":"notes/","title":"Notes","text":"<p>volumes </p> <p>Kubernetes supports many types of volumes. A Pod can use any number of volume types simultaneously. </p> <p>Ephemeral volume types have a lifetime linked to a specific Pod, but persistent volumes exist beyond the lifetime of any individual pod. When a pod ceases to exist,</p> <p>Kubernetes destroys ephemeral volumes; however, Kubernetes does not destroy persistent volumes. For any kind of volume in a given pod, data is preserved across container restarts.</p> <p>A PersistentVolume (PV) is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV</p> <p>A PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes (e.g., they can be mounted ReadWriteOnce, ReadOnlyMany, ReadWriteMany, or ReadWriteOncePod, see AccessModes).</p> <p>So lets assume that you want to use mongodb locally on your machine  typically you would run the following command in the terminal</p> <p><pre><code>docker run -d --name mongo \\\n    e MONGO_INITDB_ROOT_USERNAME = user1 \\\n    e MONGO_INITDB_ROOT_PASSWORD = password \\\n    p 1207 \n</code></pre> With this option, you can only work with the terminal. in real world, you would need to write a script that takes care of this. and thats when compose files come into the picture. with all the  commands written in the terminal, one can be able to replciate the same using a compose file this is how the above command would transalate into a a compose file as shown bwllow.</p> <p>so lets start by creating a docker compose file  <pre><code>    touch compose.yaml\n</code></pre> In the compose.yaml file, we shall then make sure that we define our appropriate configuration to  work with the mongodb docker image that we want  <pre><code>    apiVersion: v1\n    kind: Deployment\n    metadata:\n        name: deployment\n        label:\n            app: mongo\n    spec:\n        replicas: 1\n        selector:\n            matchLabels:\n                app: mongo\n        template:\n            metadata:\n                name: mongo\n                app: mongo\n            spec:\n                containers:\n                  - name: mongo\n                   image: mongo:latest\n                   ports:\n                    containerPort: 8000\n                   env:\n                    - name: MONGO_INITDB_ROOT_USER_NAME\n                      valueFrom:\n                        configMapRef:\n                            name: configmap\n                            key: MONGO_INITDB_ROOT_USER_NAME\n                    - name: MONGO_INITDB_ROOT_PASSWORD\n                      valueFrom:\n                        configMapRef:\n                            name: configmap\n                            key: MONGO_INITDB_ROOT_PASSWORD\n                volumeMounts:\n                    - name: mongo-storage\n                    mountPath: /data/db\n      volumes:\n      - name: mongo-storage\n        persistentVolumeClaim:\n          claimName: mongo-pvc\n</code></pre> so let me explain whats going on here.</p> <p>on the comman that we saw earlier when running a mongodb on our terminal, we came across environent variables that we shall cover in the sections bellow down here in a bit. </p>"},{"location":"services/auth/chapter0/","title":"Environment set up","text":""},{"location":"services/auth/chapter0/#1-installation-and-project-setup","title":"1. Installation and Project SetUp","text":"<p>In this chapter, we install FastAPI, starting with a minimal setup.</p> <p>So lets start of by creating a dicrectory that will hold our project file for the different services that we shall be creating later on. </p> <p>i will be craeating this project in the documents directory  to do this, lets naviaget to the Documents directory</p> <p><pre><code>  cd Documents \n</code></pre> Now lets create a folder and name it project. this can be watever you choose. the choice really dont matter.  <pre><code>  mkdir Project  \n</code></pre> Once this is created, we can then now start creating the different service dependent directories such as the auth-service, gateway-service, among others. </p> <p>For this part, we shall create the auth-service directory to hold our auth service.  <pre><code>  mkdir auth-service \n</code></pre> Now that we have our auth-service directory setup, next thing we need to do is to now start working with the project and then proceed. </p> <p>For this service, we shall use django as a framework because of its robust features and to do this we shall need a file that weill hold our requiremts</p> <p>Lets create a <code>requirements.txt</code> file in the auth-service directory that will hold all the priject dependancies related to the auth service that we  shall be working on. </p> <p>On Mac or Linux we shall be using the tocuh command. on other operating systems like windows, one can manually create the file. </p> <pre><code>  touch requirements.txt \n</code></pre>"},{"location":"services/auth/chapter0/#1-virtual-environment-creation","title":"1. Virtual Environment Creation","text":"<p>Lets begin by creating a virtual environment using the built-in Python module <code>venv</code>. If you already have Python installed, you might not need to install it separately. However, on Linux, installation may be necessary based on your distribution. In your commandline or terminal, type the following command.</p> <pre><code>python3 -m venv venv\n</code></pre> <p>This command generates a virtual environment in the specified folder (in our example, <code>venv</code>). Our Our environment <code>venv</code> can be any name but for the purpose of simplicity, lets go with that. This folder is an isolated Python environment that separates the dependencies of our project from the system-wide Python installation.</p> <p>Now lets go on and activate the virtual environment using the following commands:</p> <p>On Linux or macOS:</p> <pre><code>source venv/bin/activate\n</code></pre> <p>On Windows:</p> <pre><code>venv\\Scripts\\activate\n</code></pre> <p>Once activated, your command line will indicate the active virtual environment:</p> <p>On Linux or macOS:</p> <pre><code>(venv) yourusername@yourmachine$\n</code></pre> <p>On Windows:</p> <pre><code>(venv) C:\\users\\YourUsername&gt;\n</code></pre>"},{"location":"services/auth/chapter0/#2-directory-structure","title":"2. Directory Structure","text":"<p>At this point, your directory structure should look like this:</p> <pre><code>\u2514\u2500\u2500 venv\n\u2514\u2500\u2500 requiremnts.txt\n</code></pre>"},{"location":"services/auth/chapter0/#3-installing-django","title":"3. Installing Django","text":"<p>Now, let us install Django within the virtual environment. We shall install Django using <code>pip</code> with the following command.</p> <pre><code>(venv) pip install \"django\"\n</code></pre>"},{"location":"services/auth/chapter0/#4-freeze-dependencies","title":"4. Freeze Dependencies","text":"<p>Freeze the installed dependencies into a <code>requirements.txt</code> file to track the exact versions of our dependencies so that we can easily reproduce them in the future.</p> <pre><code>(env) pip freeze &gt; requirements.txt\n</code></pre>"},{"location":"services/auth/chapter0/#5-confirm-the-installation","title":"5. Confirm the installation","text":"<p>Let us confirm our FastAPI installation by running the following command.</p> <pre><code>(env) python -m django --version\n4.2\n</code></pre> <p>This command will show us the version of the Django that we installed earlier on. </p> <p>If the version has been displayed, then we are sure that Django has been installed in our virtual environment.</p>"},{"location":"services/auth/chapter0/#conclusion","title":"Conclusion","text":"<p>By following these steps, you have successfully created a project directory, set up a virtual environment, and installed Django, frozen the dependencies to reproduce the project in the future and you have verified your installation using the <code>python -m django --version</code> command. This structured approach ensures a clean and manageable development environment for our Django project. Next, we shall create the simpel auth project that we shall later on build on to create endpoints with django restframework.</p>"},{"location":"services/auth/chapter1/","title":"Creating the django project","text":""},{"location":"services/auth/chapter1/#1-introduction","title":"1. Introduction","text":"<p>So we have managed to create a directory, created a dependancy file to hold our priject dependancies, installed django and verified the installation in the previous chapter. we are now good to go.</p>"},{"location":"services/auth/chapter1/#2-creating-the-django-project","title":"2. Creating the django project.","text":"<p>To create the django project, all we need to do is to navigate to the <code>auth-service</code> directory and start run the following command. </p> <pre><code>django-admin startproject src .\n</code></pre> <p>running this command will create a django project named src in the current directory becuase we used the dot at the end of the command.</p> <p>so if we take a look at our project structure, it showuld be something like this . <pre><code>auth-service/\n\u251c\u2500\u2500 manage.py\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 settings.py\n\u2502   \u251c\u2500\u2500 urls.py\n\u2502   \u251c\u2500\u2500 wsgi.py\n\u2502   \u2514\u2500\u2500 asgi.py\n\u251c\u2500\u2500 venv/\n\u2514\u2500\u2500 requirements.txt\n</code></pre></p> <p>To make sure that our project was created successfully, we can go on and verify this by running the application server using the manage.py file that we recently saw in the project we creatred. </p> <p>Django makes its easy for us by using the manage.py script that has several commands that we can use for different commands and purpses. but for the case of this section, we shall cover the runserver command. </p> <p>To do this, lets head to our root project directory and run the command </p> <p><pre><code>cd Documents/Projects/auth-service\n</code></pre> Now that we are in the project directory, we can run the  <pre><code>(venv) python manage.py runserver\n</code></pre></p> <p>We can now go ahead and create an app that will be basically holding our app specific files and configurations for the auth service. </p> <p>At this point in time, we should be able to see something like this on our console. if you didnt see something like this, then there should be something wrong. </p> <pre><code>Watching for file changes with StatReloader\nPerforming system checks...\n\nSystem check identified no issues (0 silenced).\n\nYou have 18 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.\nRun 'python manage.py migrate' to apply them.\nAugust 19, 2025 - 13:23:31\nDjango version 5.2.5, using settings 'src.settings'\nStarting development server at http://127.0.0.1:8000/\nQuit the server with CONTROL-C.\n\nWARNING: This is a development server. Do not use it in a production setting. Use a production WSGI or ASGI server instead.\nFor more information on production servers see: https://docs.djangoproject.com/en/5.2/howto/deployment/\n</code></pre>"},{"location":"services/auth/chapter1/#3running-the-application-on-the-browser","title":"3.Running the application on the browser","text":"<p>We can now go on to the browser and navigate to the link provided on the console to be able to see our django application. </p> <p>We should be able to see something like this on the browser. </p> <p></p> <p>If you are careful enough, you might have noticed something about migrations on the console highlighted in red. This is absolutely what it says, so how do we fix that.  First lets understand migrations in django. </p>"},{"location":"services/auth/chapter1/#4-creating-the-auth-app","title":"4. Creating the auth app","text":"<p>So far everything sounds to be okay but we have one more task to do. that is to create the service app that will hold our files such as serializers, models, url configs etc. </p> <p>TO do this lets head to our project directory and create the app using the <code>` django-admin</code> command. </p> <p><pre><code>(venv) django-admin startapp app\n</code></pre> Running this command will create a app in the root directory and if we take a close look at our file structure, we can tell that diffrent files have beeen created using the command that we just previously run </p> <p>Lets naviage to this app directory and make sure we create a urls.py file which shall hold all our endpoints fror the authentication</p> <p><pre><code>cd Documents/Projects/auth-service/app\ntouch urls.py\n</code></pre> Now our updated project structure will look like this. </p> <pre><code>Project\n\u2502\n\u2502    auth-service/\n\u2502    \u2502\n\u2502    \u251c\u2500\u2500 manage.py\n\u2502    \u251c\u2500\u2500 src/\n\u2502    \u2502   \u251c\u2500\u2500 __init__.py\n\u2502    \u2502   \u251c\u2500\u2500 settings.py\n\u2502    \u2502   \u251c\u2500\u2500 urls.py\n\u2502    \u2502   \u251c\u2500\u2500 wsgi.py\n\u2502    \u2502   \u2514\u2500\u2500 asgi.py\n\u2502    \u2502\n\u2502    \u251c\u2500\u2500 app/\n\u2502    \u2502   \u251c\u2500\u2500 migrations/\n\u2502    \u2502   \u2502   \u2514\u2500\u2500 __init__.py\n\u2502    \u2502   \u251c\u2500\u2500 __init__.py\n\u2502    \u2502   \u251c\u2500\u2500 admin.py\n\u2502    \u2502   \u251c\u2500\u2500 urls.py\n\u2502    \u2502   \u251c\u2500\u2500 apps.py\n\u2502    \u2502   \u251c\u2500\u2500 models.py\n\u2502    \u2502   \u251c\u2500\u2500 tests.py\n\u2502    \u2502   \u2514\u2500\u2500 views.py\n\u2502    \u2502\n\u2502    \u251c\u2500\u2500 venv/\n\u2502    \u2502\n\u2502    \u2514\u2500\u2500\u2500requirements.txt\n\u2502    \n</code></pre>"},{"location":"services/auth/chapter1/#what-are-migrations","title":"What are migrations.","text":"<p>Django migrations are a system for propagating changes made to your models (adding a field, deleting a model, etc.) into your database schema. They are designed to be largely automatic, simplifying the process of managing database schema evolution.</p> <p>Well, for now, lets not worry about the migrations, we shall take care of that later on in the tutorial.</p> <p>So we have managed to create a directory, created a dependancy file to hold our priject dependancies, installed django and verified the installation in the previous chapter. we are now good to go.</p>"},{"location":"services/auth/chapter1/#summary","title":"Summary","text":"<p>In this section, we created a Django project named <code>src</code> and explored its structure, including the <code>manage.py</code> script and core files like <code>settings.py</code> and <code>urls.py</code>. We also learned how to run the development server to verify the project setup and navigate to the application in the browser. Additionally, we created an app named <code>app</code> to hold specific files and configurations for the authentication service, updating the project structure accordingly. Finally, we briefly introduced Django migrations and their purpose, which we will address in detail later.</p>"},{"location":"services/auth/chapter1/#conclusion","title":"Conclusion","text":"<p>By following the steps outlined in this section, we successfully set up a Django project, ran the development server, and created an app for the authentication service. These foundational steps are crucial for building and organizing a Django application. In the next sections, we will dive deeper into migrations, app configurations, and other essential aspects of Django development. </p>"},{"location":"services/auth/chapter2/","title":"Configuring the auth service","text":""},{"location":"services/auth/chapter2/#1-introduction","title":"1. Introduction","text":"<p>In the previous chapter, we were able to set up our django project, run the applicationn using the django-admin command. now in this chapter, we shall go deeper and make configuration and install the necessary tools we need to run the auth service. </p> <p>First of all. we shall need to create endpoints, we shall leverage the django restframework that will help us achieve this. to do this lets install django rest framework package and we proced. </p>"},{"location":"services/auth/chapter2/#2-django-rest-framework","title":"2. Django Rest framework","text":"<p>Django REST Framework (DRF) is a powerful and flexible toolkit for building Web APIs in conjunction with the Django web framework. It simplifies the creation of RESTful APIs by providing a set of tools and conventions that streamline common API development tasks.</p>"},{"location":"services/auth/chapter2/#features","title":"Features","text":"<p>Key features and concepts of Django REST Framework include:</p>"},{"location":"services/auth/chapter2/#1-serialization","title":"1. Serialization:","text":"<p>DRF provides serializers to convert complex data types, such as Django models and querysets, into native Python datatypes that can then be easily rendered into JSON, XML, or other content types.</p>"},{"location":"services/auth/chapter2/#2-viewsets","title":"2. Viewsets:","text":"<p>Viewsets abstract the logic for handling common API operations (like list, create, retrieve, update, destroy) into a single class, reducing code repetition.</p>"},{"location":"services/auth/chapter2/#3-routers","title":"3. Routers:","text":"<p>Routers automatically handle URL routing for viewsets, simplifying the process of mapping API endpoints to their corresponding views.</p>"},{"location":"services/auth/chapter2/#4-authentication-and-permissions","title":"4. Authentication and Permissions:","text":"<p>DRF offers various authentication schemes (e.g., TokenAuthentication, SessionAuthentication, OAuth) and permission classes to control access to API resources.</p> <p>This are some of the common ones, but for the purpose of this tutorial we shall on focus on what we need and what truly matters for our application.</p> <p>In essence, Django rest framework extends Django's capabilities to facilitate the creation of robust, maintainable, and secure RESTful APIs, making it a popular choice for developers building backend services that interact with frontend applications, mobile clients, or other systems and that is why we have chosen to go with it for our auth service.</p>"},{"location":"services/auth/chapter2/#2-installing-django-rest-framework-in-our-project","title":"2. Installing django rest framework in our project.","text":"<p>To install DRF in our proejct, lets go and install this using pip. the documentation is pretty comprehensive and easy to read. You can follow using the DRF docs here . Official Django REST Framework Documentation</p> <p>On our project directory, lets install django rest framework. <pre><code>(venv) pip install rest_framework\n</code></pre> Now if we run <code>pip freeze</code>, we can see that django restframework has been installed on our environment.</p>"},{"location":"services/auth/chapter2/#adding-the-restframework-into-the-installed-apps","title":"Adding the restframework into the installed apps","text":"<p>So once we are done installing rest framework, lets go on add it to the installed apps so that our project can recorgnise it as a dependency since this is not shipped directl with django.  <pre><code>INSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'rest_framework', # add it here\n]\n</code></pre> Lets also add the permission default permission classes into our <code>settings.py</code> file, we shall talk more baout permissions later. </p> <pre><code>REST_FRAMEWORK = {\n    # Use Django's standard `django.contrib.auth` permissions,\n    # or allow read-only access for unauthenticated users.\n    'DEFAULT_PERMISSION_CLASSES': [\n        'rest_framework.permissions.DjangoModelPermissionsOrAnonReadOnly'\n    ]\n}\n</code></pre>"},{"location":"services/auth/chapter2/#3-project-configuration-putting-it-all-together","title":"3. Project configuration (Putting it all together)","text":"<p>For every app that we create, we need to make sure that they are recorgnised by our  <code>settings.py</code> file in the <code>src</code> directory. If this doesnt happen then we are likely to face issues. </p> <p>So lets go in the <code>settings.py</code> file and add our app  This is done by adding tha pp in the installed apps as shown bellow</p> <pre><code>INSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n    'rest_framework', \n    'app', # add it here\n]\n</code></pre> <p>Now we have our app and restframework registered in the settings.py. next we have to connect our app to the main project route file. to do this we shall open the urls.py in the root directory in the <code>src</code> folder</p> <p>we shall need to make an import from the urls modules. from the coed bellow, we can see that the path is already included, so all we need to do is to add the <code>include</code> at rhe end and we are good to go </p> <p>To add the urls in the app config, we need to use the path function and include the app as shown in the code bellow </p> <p><pre><code>\"\"\"\nURL configuration for src project.\n\nThe `urlpatterns` list routes URLs to views. For more information please see:\n    https://docs.djangoproject.com/en/5.2/topics/http/urls/\nExamples:\nFunction views\n    1. Add an import:  from my_app import views\n    2. Add a URL to urlpatterns:  path('', views.home, name='home')\nClass-based views\n    1. Add an import:  from other_app.views import Home\n    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')\nIncluding another URLconf\n    1. Import the include() function: from django.urls import include, path\n    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))\n\"\"\"\nfrom django.contrib import admin\nfrom django.urls import path, inclue # import include too\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('', include('app.urls')),\n\n]\n</code></pre> At this point, you might be tempted to run the app, but i can assure you, you will get an error. why are we likely to get an error ? well the answer lies in the fact that we dont have eerything confiured as expected yet. if thats the case, then lets go on and make sure that we make things right. </p> <p>If you run  <pre><code>(venv) python manage.py runserver\n</code></pre> You will get something like this.</p> <pre><code>  File \"&lt;frozen importlib._bootstrap&gt;\", line 1387, in _gcd_import\n  File \"&lt;frozen importlib._bootstrap&gt;\", line 1360, in _find_and_load\n  File \"&lt;frozen importlib._bootstrap&gt;\", line 1324, in _find_and_load_unlocked\nModuleNotFoundError: No module named 'app.urls'\n</code></pre> <p>Now this brings us to an imporntant aspect in programming, errors. well the truth is that everytime you write code, you are likely to be faced with errors and this is absolutely normal.</p> <p>So for the error that we have, its absolutely clear that there is a modeule that is not being found when we try to run the server and that module is the app module. </p> <p>In django, if we register the app to the url configuration, we also need to make sure that this is taken care of properly from where it is coming from. </p> <p>For our case, this is coming from the <code>urls.py</code> file that we defined earlier on in the urls conf in the app module.  So lets fix that. </p> <p>So if we open our <code>urls.py</code> in the app folder, we can see that we its an empty folder so lets do somehing ther. </p> <p>We are going to define a couple of urls that will point to the different endpoints that we shall be creating in a moment </p>"},{"location":"services/auth/chapter3/","title":"Working with  models","text":""},{"location":"services/auth/chapter3/#1-working-with-models","title":"1. Working with models","text":"<p>Its time to create the models, so what we shall need to do is to head to our models.py and start modeling auth model and take care of the different stuff in the django </p>"},{"location":"services/auth/chapter3/#what-are-models","title":"What are models","text":"<p>First of all before we try wrapping our heads around how the models are going to be created, lets pause and ask what are they, what do they really help us achiveve.</p> <p>In Django, models are Python classes that define the structure and behavior of data stored in a database. They serve as the single, definitive source of information about your data, essentially acting as an abstraction layer over the database.</p> <p>Key aspects of Django Models: Python Classes: Models are defined as Python classes that subclass django.db.models.Model.</p> <p>Database Mapping: Each model typically maps to a single database table, and each attribute of the model represents a database field (column).</p> <p>Object-Relational Mapper (ORM): Django's ORM allows you to interact with your database using Python objects and methods instead of writing raw SQL queries. This simplifies database operations like creating, retrieving, updating, and deleting records. </p> <p>Field Types: Models define the types of data stored in each field (e.g., CharField for text, IntegerField for numbers, DateTimeField for dates and times), along with optional constraints like maximum length, default values, or uniqueness.</p> <p>Relationships: Models can define relationships between different database tables (e.g., one-to-one, one-to-many, many-to-many) using fields like ForeignKey or ManyToManyField.</p> <p>Automatic Features: Django automatically provides features like: An auto-incrementing primary key field (unless you specify one). An automatically generated database-access API for querying and manipulating data. Integration with the Django Admin interface for easy data management.</p> <p>Migrations: Django's migration system manages changes to your model definitions and translates them into database schema modifications, ensuring your database structure remains synchronized with your models.</p> <p>The authentication that comes with Django is good enough for most common cases, but you may have needs not met by the out-of-the-box defaults. Customizing authentication in your projects requires understanding what points of the provided system are extensible or replaceable. This document provides details about how the auth system can be customized.</p> <p>In this example, the Post model defines a database table for users with fields for username, first name, email and  last name. The str method defines how a Auth object will be represented as a string, which is useful in the Django Admin and other contexts.</p> auth-service/app/models.py<pre><code>from django.db import models\n\nclass Auth(models.Model):\n    username = models.CharField(max_length=200)\n    first_name = models.TextField()\n    last_name = models.DateTimeField(auto_now_add=True)\n    email = models.TextField()\n\n    def __str__(self):\n        return self.username\n</code></pre> <p>So now that you have a glimpse of how a model is created, lets create  our auth model based on the concepts  that you have covered above. </p> <p>What we shall be creating will be a little more complex based on what you have seen in the example.  but lets not worry about the complexity as i will explain as we go on. </p> <p>We shall be  creating a custom user model in Django that uses email, username, and password for user registration. We will also modify the user model to remove certain fields that are not needed for our application.</p> <p>First of all, we need to create a custom user manager that will handle user creation. This manager will ensure that users can be created with an email and username.</p> <p>Lets create a file named <code>auth-service/app/models.py</code> like this</p> <p>auth-service/app/models.py<pre><code>from django.db import models\nfrom django.contrib.auth.models import BaseUserManager\n\nclass CustomUserManager(BaseUserManager):\n\n    def create_user(self, email, username, password=None, **extra_fields):\n        if not email:\n            raise ValueError(\"The Email field must be set\")\n        if not username:\n            raise ValueError(\"The Username field must be set\")\n\n        email = self.normalize_email(email)\n        user = self.model(email=email, username=username, **extra_fields)\n        user.set_password(password)\n        user.save(using=self._db)\n        return user\n\n    def create_superuser(self, email, username, password=None, **extra_fields):\n        extra_fields.setdefault('is_staff', True)\n        extra_fields.setdefault('is_superuser', True)\n\n        if extra_fields.get('is_staff') is not True:\n            raise ValueError(\"Superuser must have is_staff=True.\")\n        if extra_fields.get('is_superuser') is not True:\n            raise ValueError(\"Superuser must have is_superuser=True.\")\n\n        return self.create_user(email, username, password, **extra_fields)\n</code></pre> Okay Seems to be pretty much but lets condence it so that you have an idea of whats going on in the custom user manager that we recently created.  </p>"},{"location":"services/auth/chapter3/#1-the-create_user-method-or-function","title":"1. The <code>create_user</code> method or function","text":"<p>This method creates a regular user. It checks if the email and username are provided, normalizes the email, and sets the password securely before saving the user.</p> <p>We need the user to give us their email and username, if a user doesnt do this, we shouldnt let the user to proced. so we do some validation as shown bellow. same with email </p> <pre><code> if not email:\n    raise ValueError(\"The Email field must be set\")\n</code></pre> <p>Assuming that the user enters an email like <code>example@gMail.com</code>, its first of ugly and we dont really want to store ugly stuff in our database, so we normalise it by lowering the domain portion of the email adress to make it something like <code>example@gmail.com</code>. this is done on this line <code>email = self.normalize_email(email)</code></p>"},{"location":"services/auth/chapter3/#1-create_superuser","title":"1. create_superuser:","text":"<p>This method creates a superuser with elevated permissions. It ensures that the superuser has the <code>is_staff</code> and <code>is_superuser</code> fields set to True.</p>"},{"location":"services/auth/chapter3/#creating-the-custom-user-model","title":"Creating the Custom User Model","text":"<p>Next, lets also create the custom user model that will use our custom user manager. Update the <code>auth-service/app/models.py</code> models.py file as follows:</p> auth-service/app/models.py<pre><code>from django.contrib.auth.models import AbstractUser\n\nclass User(AbstractUser):\n    username = models.CharField(max_length=150, unique=True, blank=False, null=False)\n    first_name = models.CharField(max_length=30, blank=True, null=True)\n    last_name = models.CharField(max_length=30, blank=True, null=True)\n    email = models.EmailField(unique=True, blank=False, null=False)\n    is_active = models.BooleanField(default=True)\n    api_token = models.CharField(max_length=255, blank=True, null=True)\n\n    objects = CustomUserManager()\n\n    REQUIRED_FIELDS = ['email']  # Ensure email is required for creates\n    USERNAME_FIELD = 'username'  # Use username as the unique identifier\n\n    def __str__(self):\n        return self.username\n\n    class Meta:\n        verbose_name = 'account'\n        verbose_name_plural = 'accounts'\n</code></pre> <p>To break this peiece of code down, lets remember why we created this. our table needs fields like the <code>username</code>, <code>first name</code>, <code>last name</code> and <code>email</code> to represent a user.</p> <p>This are the fields that we shall be creating in our database my using the above table which will inhereit from the <code>Abstractuser</code> </p> <p>So here is a summerised information about each field that we defined earlier on in the User table.</p> <p><code>username</code>: A unique field for the user's username. <code>first_name</code> and <code>last_name</code>: Optional fields for the user's first and last names. <code>email</code>: A unique field for the user's email address. <code>is_active</code>: A boolean field to indicate if the user account is active. <code>api_token</code>: A field to store an API token for the user. <code>objects</code>: This line assigns our custom user manager to the model. <code>REQUIRED_FIELDS</code>: This specifies that the email field is required when creating a user. <code>USERNAME_FIELD</code>: This indicates that the username will be used as the unique identifier for authentication.</p> <p>Once we are done with this setup, we have introduced a new table <code>User</code> that has custom fields that is not shipped directly with django and we need to let the <code>settings.py</code> know about this. so we shall open our <code>settings.py</code> and add it </p> auth-service/src/settings.py<pre><code>...\nREST_FRAMEWORK = {\n    # Use Django's standard `django.contrib.auth` permissions,\n    # or allow read-only access for unauthenticated users.\n    'DEFAULT_PERMISSION_CLASSES': [\n        'rest_framework.permissions.DjangoModelPermissionsOrAnonReadOnly'\n    ]\n}\n\nAUTH_USER_MODEL = 'app.User' # add it here \n\nROOT_URLCONF = 'src.urls'\n...\n</code></pre>"},{"location":"services/auth/chapter3/#registering-the-user-model","title":"Registering the User model.","text":"<p>For every model that we create, if we want to interact with it, we need to add it to the <code>admin.py</code> which is a central repository for managing different models with the django admin panel. To do this we start by importing the model and then use the register method as shown bellow.</p> auth-service/app/admin.py<pre><code>from django.contrib import admin\nfrom app.models import User\n\nadmin.site.register(User)\n</code></pre>"},{"location":"services/auth/chapter3/#making-migrations","title":"Making migrations","text":"<p>Earlier on we saw that we have about 18 unapplied migrations. this is true because our database doesnt have our tables, even the ones that come shipped with the django. so in django migrations help us to manage our database tables in an effiecient way using the Object Relatioanl Mapper (ORM).</p> <p>So we can now go ahead and make the migrations using the the following commands. For more, you can read the Django Migrations Documentation. that has detailed information. but for now, we shall only focus on what matters and that is making and applying the migrations.</p> <p>So we can now go ahead and make the migrations using the following commands:</p> <pre><code>(venv) python manage.py makemigrations\n(venv) python manage.py migrate\n</code></pre>"},{"location":"services/auth/chapter3/#putting-it-all-together-models","title":"Putting It All Together: Models","text":"<p>At this point, we have successfully created a custom user model and a custom user manager to handle user creation and authentication. Here's a summary of what we've done:</p> <ol> <li> <p>Created a <code>CustomUserManager</code>:</p> <ul> <li>This manager includes methods for creating regular users (<code>create_user</code>) and superusers (<code>create_superuser</code>).</li> <li>It validates that both <code>email</code> and <code>username</code> are provided during user creation.</li> <li>It normalizes email addresses and securely sets passwords before saving users.</li> </ul> </li> <li> <p>Created a <code>User</code> Model:</p> <ul> <li>This model extends Django's <code>AbstractUser</code> to customize the user fields.</li> <li>It includes fields like <code>username</code>, <code>email</code>, <code>first_name</code>, <code>last_name</code>, <code>is_active</code>, and <code>api_token</code>.</li> <li>It uses the <code>CustomUserManager</code> for user management.</li> <li>It defines <code>USERNAME_FIELD</code> as <code>username</code> and includes <code>REQUIRED_FIELDS</code> to ensure <code>email</code> is mandatory.</li> </ul> </li> <li> <p>Integrated the Custom User Model:</p> <ul> <li>We updated the <code>AUTH_USER_MODEL</code> setting in <code>settings.py</code> to point to our custom user model (<code>app.User</code>).</li> </ul> </li> <li> <p>Registered the Model in the Admin Panel:</p> <ul> <li>We registered the <code>User</code> model in <code>admin.py</code> to manage it via the Django Admin interface.</li> </ul> </li> <li> <p>Applied Migrations:</p> <ul> <li>We used Django's migration system to create the necessary database schema for our custom user model.</li> </ul> </li> </ol>"},{"location":"services/auth/chapter3/#complete-code-for-models","title":"Complete Code for Models","text":"<p>Here is the final code for the models:</p> auth-service/app/models.py<pre><code>from django.db import models\nfrom django.contrib.auth.models import BaseUserManager, AbstractUser\n\nclass CustomUserManager(BaseUserManager):\n    def create_user(self, username, email, password=None, **extra_fields):\n        if not email:\n            raise ValueError(\"The Email field must be set\")\n        email = self.normalize_email(email)\n        user = self.model(username=username, email=email, **extra_fields)\n        user.set_password(password)\n        user.save(using=self._db)\n        return user\n\n    def create_superuser(self, username, email, password=None, **extra_fields):\n        extra_fields.setdefault('is_staff', True)\n        extra_fields.setdefault('is_superuser', True)\n\n        if extra_fields.get('is_staff') is not True:\n            raise ValueError(\"Superuser must have is_staff=True.\")\n        if extra_fields.get('is_superuser') is not True:\n            raise ValueError(\"Superuser must have is_superuser=True.\")\n\n        return self.create_user(username, email, password, **extra_fields)\n\nclass User(AbstractUser):\n    username = models.CharField(max_length=150, unique=True, blank=False, null=False)\n    first_name = models.CharField(max_length=30, blank=True, null=True)\n    last_name = models.CharField(max_length=30, blank=True, null=True)\n    email = models.EmailField(unique=True, blank=False, null=False)\n    is_active = models.BooleanField(default=True)\n    is_staff = models.BooleanField(default=False)\n    is_superuser = models.BooleanField(default=False)\n    date_joined = models.DateTimeField(auto_now_add=True)\n    last_login = models.DateTimeField(blank=True, null=True)\n    api_token = models.CharField(max_length=255, blank=True, null=True)\n\n    objects = CustomUserManager()\n\n    REQUIRED_FIELDS = []\n    USERNAME_FIELD = 'username'\n\n    def __str__(self):\n        return self.username\n\n    class Meta:\n        verbose_name = 'account'\n        verbose_name_plural = 'accounts'\n</code></pre> <p>With this setup, we now have a fully functional custom user model that can be used for authentication and user management in our Django application. This marks a significant milestone in building a robust and extensible authentication system.</p>"},{"location":"services/auth/chapter3/#2-working-with-serializers","title":"2. Working with serializers.","text":"<p>We have come from  far to this point that we totaly unsertand what is happening to our auth class and now its time to create provision to take care of the data, to be able to model it into JSOn format. </p> <p>This process is called serialization and to achieve this we shall use serilizers from the django rest framework to return an appropriate format for our data </p>"},{"location":"services/auth/chapter3/#what-are-serializers","title":"What are serializers","text":"<p>Serializers allow complex data such as querysets and model instances to be converted to native Python datatypes that can then be easily rendered into JSON,</p> <p>So now that we know about serializers, we need to go ahead and create the serializers file in our app directory <code>auth-service/app/serializers.py</code> </p> <pre><code>(venv) cd auth-service/app/\n(venv) touch serializers.py\n</code></pre> <p>Serializers goes hand in hand with the models. we can not serialize something that we dont have. so we need to import the model that we recently created. We shall also need to use the django restframework to create the serializers. </p> <p>The process of creating the serializers is not that different from the proces off defining the models. For this tutorial, we shall focus more on creating a simple serializer what uses the model (User) that we created earlier on.</p> <p>Lets define a <code>UserSerializer</code> class that we shall use to serialize our data. To serialize our data, we shall use the <code>ModelSerializer</code> class that comes from the serializer module in the django rest framework.</p> <p>auth-service/app/serializers.py<pre><code>from rest_framework import serializers\nfrom app.models import User \n\nclass UserSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = User\n        fields = ('id', 'username', 'password')\n        extra_kwargs = {'password': {'write_only': True}}\n</code></pre> And then a <code>Meta</code> class which we will use a model <code>User</code> we just imported, this will be also accampnied <code>fields</code> and <code>extra_kwargs</code>. To break this down, In the fields, we specify the fields that we want to expose as JSONand then extra attributes such as making password <code>write_only</code> for security purposes.</p> <p>This is basic, so lets spice this up by defining a <code>create</code> method that will take care of a couple of things.</p> <p>One more thing to do, lets install <code>jwt</code> using pip</p> <p><pre><code>(venv) pip install jwt\n</code></pre> This will install jwt that we shall use to encode our sensitive infromation while creating a user.</p> auth-service/app/serializers.py<pre><code>from rest_framework import serializers\nfrom app.models import User \n\nimport jwt\nfrom django.contrib.auth.hashers import make_password\nfrom django.conf import settings\nclass UserSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = User\n        fields = ('id', 'username', 'password')\n        extra_kwargs = {'password': {'write_only': True}}\n\n    def create(self, validated_data):\n        user = User.objects.create(\n            username=validated_data['username'],\n            password=make_password(validated_data['password'])\n        )\n        user.api_token = jwt.encode(\n            {'user_id': user.id}, \n            settings.SECRET_KEY, \n            algorithm='HS256'\n        )\n        user.save()\n        return user\n</code></pre> <p>In the code above, we also import a couple of functions like <code>make_password</code>, <code>jwt</code>and  <code>settings</code>  From the above code, we create a <code>user</code> using the <code>User</code> class with a validated username and password then use the newly created user and assign a token which is encoded using the <code>secret key</code>, <code>user_id</code> and <code>HS256</code> algorthm. Later on we save the user in our database.</p> <p>Lets also create a token serializer that will convert our token into a JSON compatible response that we need for our enpoint. For this we shall use the basic serializer from restframework serializer module.</p> auth-service/app/serializers.py<pre><code>class TokenSerializer(serializers.Serializer):\n    token = serializers.CharField()\n</code></pre>"},{"location":"services/auth/chapter3/#putting-it-all-together-serializers","title":"Putting It All Together: Serializers","text":"<p>At this point, we have successfully created serializers to handle the conversion of our <code>User</code> model data into JSON format and vice versa. Here's a summary of what we've done:</p> <ol> <li> <p>Created a <code>UserSerializer</code>:</p> <ul> <li>This serializer is based on the <code>User</code> model and exposes the <code>id</code>, <code>username</code>, and <code>password</code> fields.</li> <li>The <code>password</code> field is marked as <code>write_only</code> to ensure it is not exposed in API responses.</li> <li>A <code>create</code> method was implemented to handle user creation, including:</li> <li>Hashing the password using <code>make_password</code>.</li> <li>Generating a JWT token for the user using the <code>user_id</code> and the <code>SECRET_KEY</code> from the settings.</li> <li>Saving the user with the generated token.</li> </ul> </li> <li> <p>Created a <code>TokenSerializer</code>:</p> <ul> <li>This simple serializer is used to represent the token as a JSON-compatible response.</li> </ul> </li> <li> <p>Installed <code>jwt</code>:</p> <ul> <li>The <code>jwt</code> library was installed to handle token encoding for secure user authentication.</li> </ul> </li> </ol>"},{"location":"services/auth/chapter3/#complete-code-for-serializers","title":"Complete Code for Serializers","text":"<p>Here is the final code for the serializers:</p> auth-service/app/serializers.py<pre><code>import jwt\nfrom rest_framework import serializers\nfrom app.models import User \n\nfrom django.contrib.auth.hashers import make_password\nfrom django.conf import settings\n\n\nclass UserSerializer(serializers.ModelSerializer):\n     class Meta:\n          model = User\n          fields = ('id', 'username', 'password')\n          extra_kwargs = {'password': {'write_only': True}}\n\n     def create(self, validated_data):\n          user = User.objects.create(\n                username=validated_data['username'],\n                password=make_password(validated_data['password'])\n          )\n          user.api_token = jwt.encode(\n                {'user_id': user.id}, \n                settings.SECRET_KEY, \n                algorithm='HS256'\n          )\n          user.save()\n          return user\n\nclass TokenSerializer(serializers.Serializer):\n     token = serializers.CharField()\n</code></pre> <p>With these serializers in place, we are now ready to integrate them into our views and endpoints to handle user registration and token-based authentication. This marks a significant step in building a robust authentication system for our application.</p> <p>This is not that much what is expected from signing and encryption but for this tutorial. it fits the purpose.</p>"},{"location":"services/auth/chapter4/","title":"Working with views","text":"<p>Now that we have our models configured up and running, its time to use these models and make sure we come up with the view for our application. </p> <p>Lets see how the user auth app would work logically.  A user signs into the application by registering, the user is saved in our postgres database in a relational database table structure. </p> <p>This is where the postgres comes in but for now we shall use the SQLlite database that will store the data. </p> <p>The user then uses the credentials(username and password) to login to the sytem, once the user is loggedin, we asssign them a token that will be used to access the system resources. </p> <p>But we can not just use this token just like that, so we shall have to validate that token. </p> <p>So if you are following allong, you can guess that we need three endpoints for this auth service.  This will be      Register endpoint that will fields from the models that we created earlier on     Login endpoint that will use the username and password to access the system resouces      Validate toke endpoint. this will make sure the token is valid and trusted. </p>"},{"location":"services/auth/chapter4/#registering-the-user","title":"Registering the user","text":"<p>Lets go on and create our first endpoint. The <code>Register</code> enpoint. This will inhreit from the APIView that we recently imported. </p> auth-service/app/views.py<pre><code>import jwt\nfrom rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom rest_framework import status\nfrom app.serializers import UserSerializer,\n\nClass RegisterView(APIVIew):\n\n    serializer_class = UserSerializer()\n\n    def post(self, request, *args, **kwargs):\n        if request.method=\"POST\":\n            serializer = self.serializer_class(data=request.data)\n            if serializer.is_valid:\n                user = serializer.save()\n                return Response({\n                    'user_id': user.id,\n                    'token': user.api_token\n                }, status=status.HTTP_201_CREATED)\n            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n</code></pre> <p>This section explains how to create a Register endpoint for user registration in a Django REST Framework application. The RegisterView class inherits from APIView and uses a UserSerializer to validate and save user data.</p> <p>The post method handles HTTP POST requests, checks if the request data is valid, and saves the user. If successful, it returns the user's ID and token with a 201 Created status. If validation fails, it returns the errors with a 400 Bad Request status. </p> <p>This endpoint is part of an authentication service that will later include login and token validation endpoints.</p>"},{"location":"services/auth/chapter4/#logging-in-the-user","title":"Logging in the user","text":"<p>Lets also take care of the <code>Login</code> endpoint .</p> <p>auth-service/app/views.py<pre><code>import jwt\nfrom rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom rest_framework import status\nfrom app.serializers import UserSerializer,\nfrom app.models import Account\nfrom app.serializers import UserSerializer, TokenSerializer\nfrom django.conf import settings\nfrom django.contrib.auth import authenticate\n\nclass LoginView(APIView):\n\n    def post(self, request):\n        username = request.data.get('username')\n        password = request.data.get('password')\n        user = authenticate(username=username, password=password)\n        if user:\n            token = jwt.encode(\n                {'user_id': user.id}, \n                settings.SECRET_KEY, \n                algorithm='HS256'\n            )\n            return Response({'token': token})\n        return Response({'error': 'Invalid credentials'}, status=status.HTTP_401_UNAUTHORIZED)\n</code></pre> In the code above we define a LoginView class that handles user login requests in a Django REST Framework (DRF) application.</p> <p>We extracts the username and password from the request, authenticate the user against the database, and, if successful, we generate a JWT token containing the user's ID.</p> <p>The token is signed using a secret key and the HS256 algorithm. If authentication fails, we return an error response with a 401 status. This demonstrates a basic token-based authentication flow.</p>"},{"location":"services/auth/chapter4/#validating-the-token","title":"Validating the token","text":"<p>Now that we have a user loggedin and they have got a toke, Its better we make sure that the above token is valid.</p> auth-service/app/views.py<pre><code>class ValidateTokenView(APIView):\n\n    def post(self, request):\n        token = request.META.get('HTTP_AUTHORIZATION', '').split(' ')[-1]\n        if not token:\n            return Response({'error': 'Token missing'}, status=status.HTTP_400_BAD_REQUEST)\n\n        try:\n            payload = jwt.decode(token, settings.SECRET_KEY, algorithms=['HS256'])\n            user = Account.objects.get(id=payload['user_id'])\n            return Response({'valid': True, 'user_id': user.id})\n        except (jwt.ExpiredSignatureError, jwt.DecodeError, Account.DoesNotExist):\n            return Response({'valid': False}, status=status.HTTP_401_UNAUTHORIZED)\n</code></pre> <p>In our code we  defined a ValidateTokenView class, which is responsible for verifying the validity of a JWT (JSON Web Token) provided in the Authorization header of an HTTP request. Here's the process in brief:</p> <p>The token is retrieved from the Authorization header in the request's META object. If the token is missing, a 400 Bad Request response is returned with an error message.</p> <p>The token is decoded using the jwt.decode method, with the secret key and hashing algorithm used during token creation. This ensures the token's integrity and authenticity.</p> <p>The decoded token payload is used to fetch the user from the database. If the user exists and matches the token's user_id, a success response is returned with valid: True and the user_id.</p> <p>If the token is expired, invalid, or the user does not exist, a 401 Unauthorized response is returned with valid: False. This ensures that unauthorized access is denied.</p>"},{"location":"services/auth/chapter4/#putting-it-all-together-views","title":"Putting It All Together: Views","text":"<p>To bring everything together, we now have three endpoints that handle user authentication: <code>Register</code>, <code>Login</code>, and <code>ValidateToken</code>. These endpoints work in harmony to ensure that users can securely interact with the system.</p> <ol> <li> <p>Register Endpoint: This endpoint allows new users to create an account. It validates the input data, saves the user to the database, and returns a token for further interactions.</p> </li> <li> <p>Login Endpoint: This endpoint authenticates existing users by verifying their credentials. Upon successful authentication, it generates and returns a token that the user can use to access protected resources.</p> </li> <li> <p>ValidateToken Endpoint: This endpoint ensures that the token provided by the user is valid and corresponds to an existing user in the system. It protects the system from unauthorized access.</p> </li> </ol>"},{"location":"services/auth/chapter4/#example-workflow","title":"Example Workflow","text":"<p>Here\u2019s how the endpoints work together in a typical user authentication flow:</p> <ol> <li> <p>User Registration:</p> <ul> <li>The user sends a <code>POST</code> request to the <code>Register</code> endpoint with their details.</li> <li>The system validates the data, creates the user, and returns a token.</li> </ul> </li> <li> <p>User Login:</p> <ul> <li>The user sends a <code>POST</code> request to the <code>Login</code> endpoint with their username and password.</li> <li>The system authenticates the user and returns a token if the credentials are valid.</li> </ul> </li> <li> <p>Token Validation:</p> <ul> <li>The user includes the token in the <code>Authorization</code> header when accessing protected resources.</li> <li>The system sends the token to the <code>ValidateToken</code> endpoint to ensure it is valid before granting access.</li> </ul> </li> </ol>"},{"location":"services/auth/chapter4/#complete-code-for-views","title":"Complete Code for Views","text":"<p>Here is the final code for the views</p> auth-service/app/views.py<pre><code>import jwt\nfrom rest_framework.views import APIView\nfrom rest_framework.response import Response\nfrom rest_framework import status\nfrom app.models import Account\nfrom app.serializers import UserSerializer, TokenSerializer\nfrom django.conf import settings\nfrom django.contrib.auth import authenticate\n\n\nclass RegisterView(APIView):\n\n    serializer_class = UserSerializer()\n\n    def post(self, request):\n        serializer = self.serializer_class(data=request.data)\n        if serializer.is_valid():\n            user = serializer.save()\n            return Response({\n                'user_id': user.id,\n                'token': user.api_token\n            }, status=status.HTTP_201_CREATED)\n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n\nclass LoginView(APIView):\n\n    def post(self, request):\n        username = request.data.get('username')\n        password = request.data.get('password')\n        user = authenticate(username=username, password=password)\n        if user:\n            token = jwt.encode(\n                {'user_id': user.id}, \n                settings.SECRET_KEY, \n                algorithm='HS256'\n            )\n            return Response({'token': token})\n        return Response({'error': 'Invalid credentials'}, status=status.HTTP_401_UNAUTHORIZED)\n\nclass ValidateTokenView(APIView):\n\n    def post(self, request):\n        token = request.META.get('HTTP_AUTHORIZATION', '').split(' ')[-1]\n        if not token:\n            return Response({'error': 'Token missing'}, status=status.HTTP_400_BAD_REQUEST)\n\n        try:\n            payload = jwt.decode(token, settings.SECRET_KEY, algorithms=['HS256'])\n            user = Account.objects.get(id=payload['user_id'])\n            return Response({'valid': True, 'user_id': user.id})\n        except (jwt.ExpiredSignatureError, jwt.DecodeError, Account.DoesNotExist):\n            return Response({'valid': False}, status=status.HTTP_401_UNAUTHORIZED)\n</code></pre>"},{"location":"services/auth/chapter4/#next-steps","title":"Next Steps","text":"<p>With these endpoints in place, you can now integrate them into our lets </p> <p>By following this structure, you\u2019ve laid the foundation for a secure and scalable authentication service. Great work!</p>"},{"location":"services/auth/chapter5/","title":"Routing and configuration","text":""},{"location":"services/auth/chapter5/#configuring-urls-for-the-views","title":"Configuring URLs for the Views","text":"<p>To make the authentication views accessible, we need to configure the URLs for each endpoint. This involves mapping the views to specific URL patterns in the <code>urls.py</code> file of the <code>auth-service</code> app.</p> <p>Here\u2019s how you can set it up:</p> auth-service/app/urls.py<pre><code>from django.urls import path\nfrom .views import RegisterView, LoginView, ValidateTokenView\n\nurlpatterns = [\n    path('register/', RegisterView.as_view(), name='register'),\n    path('login/', LoginView.as_view(), name='login'),\n    path('validate-token/', ValidateTokenView.as_view(), name='validate-token'),\n]\n</code></pre>"},{"location":"services/auth/chapter5/#explanation","title":"Explanation","text":"<ol> <li>Register Endpoint:</li> <li>URL: <code>/register/</code></li> <li>View: <code>RegisterView</code></li> <li> <p>Purpose: Allows users to create an account.</p> </li> <li> <p>Login Endpoint:</p> </li> <li>URL: <code>/login/</code></li> <li>View: <code>LoginView</code></li> <li> <p>Purpose: Authenticates users and provides a token.</p> </li> <li> <p>ValidateToken Endpoint:</p> </li> <li>URL: <code>/validate-token/</code></li> <li>View: <code>ValidateTokenView</code></li> <li>Purpose: Validates the token provided by the user.</li> </ol>"},{"location":"services/auth/chapter5/#next-steps","title":"Next Steps","text":"<p>With the URLs configured, you can now test the endpoints using tools like Postman or curl. Ensure that each endpoint behaves as expected and returns the appropriate responses. This completes the setup for the authentication service!</p>"},{"location":"services/auth/chapter6/","title":"Dockerising our auth service","text":""},{"location":"services/auth/chapter6/#core-concepts","title":"Core Concepts","text":""},{"location":"services/auth/chapter6/#1-docker-hub","title":"1. Docker Hub","text":"<p>Docker Hub is a cloud-based registry where you can store and share container images. It allows you to distribute your applications and collaborate with others. Docker Hub provides both public and private repositories for your images.</p>"},{"location":"services/auth/chapter6/#2-container-images","title":"2. Container Images","text":"<p>A container image is a lightweight, standalone, and executable package that includes everything needed to run a piece of software. This includes the code, runtime, libraries, and dependencies.</p> <p>Now that we have our application up and running, next we need to containerise our application as this will be essential for them to communicate with other services that we shall be creating later on iin the course. </p>"},{"location":"services/auth/chapter6/#prerequisites","title":"Prerequisites","text":"<p>Before proceeding, ensure you have: - Administrative privileges on your machine. - A stable internet connection.</p>"},{"location":"services/auth/chapter6/#installing-docker","title":"Installing Docker","text":""},{"location":"services/auth/chapter6/#macos","title":"macOS","text":"<ol> <li>Install Docker:<ul> <li>Download Docker Desktop for Mac from Docker's official website.</li> <li>Run the installer and follow the on-screen instructions.</li> <li>Verify installation: <pre><code>docker --version\n</code></pre></li> </ul> </li> <li>Install Kubernetes:<ul> <li>Kubernetes is included with Docker Desktop. Enable Kubernetes in Docker Desktop settings.</li> <li>Verify installation: <pre><code>kubectl version --client\n</code></pre></li> </ul> </li> </ol>"},{"location":"services/auth/chapter6/#windows","title":"Windows","text":"<ol> <li>Install Docker:<ul> <li>Download Docker Desktop for Windows from Docker's official website.</li> <li>Ensure WSL 2 is enabled (required for Docker Desktop).</li> <li>Run the installer and follow the on-screen instructions.</li> <li>Verify installation: <pre><code>docker --version\n</code></pre></li> </ul> </li> <li>Install Kubernetes:<ul> <li>Kubernetes is included with Docker Desktop. Enable Kubernetes in Docker Desktop settings.</li> <li>Verify installation: <pre><code>kubectl version --client\n</code></pre></li> </ul> </li> </ol>"},{"location":"services/auth/chapter6/#linux","title":"Linux","text":"<ol> <li>Install Docker:<ul> <li>Follow the official Docker Engine installation guide for your Linux distribution: Docker Linux Install.</li> <li>Start and enable the Docker service:   <pre><code>sudo systemctl start docker\nsudo systemctl enable docker\n</code></pre></li> <li>Verify installation: <pre><code>docker --version\n</code></pre></li> </ul> </li> <li>Install Kubernetes:<ul> <li>Install <code>kubectl</code> using the official guide: Install kubectl.</li> <li>Optionally, install Minikube for a local Kubernetes cluster: Install Minikube.</li> <li>Verify installation: <pre><code>kubectl version --client\n</code></pre></li> </ul> </li> </ol>"},{"location":"services/auth/chapter6/#testing-docker-installation","title":"Testing docker installation","text":"<p>We can test to see if docker has been installed using the commanf bellow</p> <p><pre><code>docker run hello-world\n</code></pre> To also test Kubernetes, which we shall alter use in the course, we can do this  by deploying a sample application:</p> <pre><code>kubectl create deployment hello-node --image=k8s.gcr.io/echoserver:1.4\nkubectl expose deployment hello-node --type=LoadBalancer --port=8080\n</code></pre> <p>Later on in the course we shall learn and apply more about kubernettes. for now lets focus on docker.</p> <p>Since we have our app up and running, we should be thingking of deploying this application. We shall use docker to make this happen. </p> <p>Now that you\u2019ve built your Docker image, you\u2019re ready to publish it to Docker Hub. This guide will walk you through the steps required to share your image with others.</p>"},{"location":"services/auth/chapter6/#dockerising-auth-service","title":"Dockerising auth service","text":"<p>Dockerise here</p>"},{"location":"services/auth/chapter7/","title":"Publishing our auth service","text":""},{"location":"services/auth/chapter7/#1-sign-in-to-docker-hub","title":"1. Sign in to Docker Hub","text":"<p>To push images to Docker Hub, you need to sign in with your Docker account.</p> <ul> <li>Open a terminal and run:     <pre><code>docker login\n</code></pre></li> <li>Enter your Docker Hub username and password when prompted.</li> </ul> <p>Alternatively, you can sign in via the Docker Desktop application.</p>"},{"location":"services/auth/chapter7/#2-create-a-repository","title":"2. Create a Repository","text":"<p>Before pushing your image, you need a repository to store it.</p> <ul> <li>Go to Docker Hub.</li> <li>Click on Create Repository.</li> <li>Fill in the following details:<ul> <li>Repository Name: Choose a name for your repository (e.g., <code>my-app</code>).</li> <li>Visibility: Select Public or Private based on your preference.</li> </ul> </li> <li>Click Create to finalize.</li> </ul>"},{"location":"services/auth/chapter7/#3-build-your-docker-image","title":"3. Build Your Docker Image","text":"<p>Before tagging and pushing your image, you need to build it from your Dockerfile.</p> <ul> <li>Navigate to the directory containing your Dockerfile.</li> <li>Run the following command to build the image:     <pre><code>docker build -t docker_username/app_name .\n</code></pre></li> <li>Example:     <pre><code>docker build -t my-app:1.0 .\ndocker build -t &lt;DOCKER_USERNAME&gt;/getting-started-todo-app .\n</code></pre></li> </ul> <p>This command creates a Docker image with the specified tag (<code>local-image:tagname</code>) based on the instructions in your Dockerfile.</p> <p>By default it will create an image with the latest tag.</p>"},{"location":"services/auth/chapter7/#4-tag-your-docker-image","title":"4. Tag Your Docker Image","text":"<p>Tag your local Docker image to match the repository name on Docker Hub.</p> <ul> <li>Use the following command:     <pre><code>docker tag local-image:tagname your-dockerhub-username/repository-name:tagname\ndocker build  -t okotdaniel/auth-service .\n</code></pre></li> <li>Example:     <pre><code>docker tag my-app:1.0 johndoe/my-app:1.0\n</code></pre></li> </ul>"},{"location":"services/auth/chapter7/#5-push-the-image-to-docker-hub","title":"5. Push the Image to Docker Hub","text":"<p>Push the tagged image to your Docker Hub repository.</p> <ul> <li>Run the following command:     <pre><code>docker push your-dockerhub-username/repository-name:tagname\n</code></pre></li> <li>Example:     <pre><code>docker push johndoe/my-app:1.0\n</code></pre></li> </ul>"},{"location":"services/auth/chapter7/#6-verify-the-image-on-docker-hub","title":"6. Verify the Image on Docker Hub","text":"<ul> <li>Visit your Docker Hub account and navigate to the repository.</li> <li>Confirm that the image has been successfully uploaded.</li> </ul>"},{"location":"services/auth/chapter7/#recap","title":"Recap","text":"<p>In this tutorial, you learned how to:</p> <ul> <li>Sign in to Docker Hub.</li> <li>Create a repository to store your image.</li> <li>Tag and push your Docker image to Docker Hub.</li> </ul> <p>By following these steps, you can easily share your containerized applications with others or use them in your own projects.</p>"},{"location":"services/auth/chapter7/#next-steps","title":"Next Steps","text":"<p>Explore Docker Hub to discover other images you can use as a base for your projects. Additionally, consider learning about private registries if you need to store sensitive or proprietary images.</p>"},{"location":"services/gateway/chapter1/","title":"Creating the django project","text":""},{"location":"services/gateway/chapter1/#1-installation-and-project-setup","title":"1. Installation and Project SetUp","text":"<p>In this chapter, we install FastAPI, starting with a minimal setup.</p> <p>So lets start of by creating a dicrectory that will hold our project file for the different services that we shall be creating later on. </p> <p>i will be craeating this project in the documents directory  to do this, lets naviaget to the Documents directory</p> <p><pre><code>  cd Documents \n</code></pre> Now lets create a folder and name it project. this can be watever you choose. the choice really dont matter.  <pre><code>  mkdir Project  \n</code></pre> Once this is created, we can then now start creating the different service dependent directories such as the auth-service, gateway-service, among others. </p> <p>For this part, we shall create the auth-service directory to hold our auth service.  <pre><code>  mkdir auth-service \n</code></pre> Now that we have our auth-service directory setup, next thing we need to do is to now start working with the project and then proceed. </p> <p>For this service, we shall use django as a framework because of its robust features and to do this we shall need a file that weill hold our requiremts</p> <p>Lets create a <code>requirements.txt</code> file in the auth-service directory that will hold all the priject dependancies related to the auth service that we  shall be working on. </p> <p>On Mac or Linux we shall be using the tocuh command. on other operating systems like windows, one can manually create the file. </p> <pre><code>  touch requirements.txt \n</code></pre>"},{"location":"services/gateway/chapter1/#1-virtual-environment-creation","title":"1. Virtual Environment Creation","text":"<p>Lets begin by creating a virtual environment using the built-in Python module <code>venv</code>. If you already have Python installed, you might not need to install it separately. However, on Linux, installation may be necessary based on your distribution. In your commandline or terminal, type the following command.</p> <pre><code>python3 -m venv venv\n</code></pre> <p>This command generates a virtual environment in the specified folder (in our example, <code>venv</code>). Our Our environment <code>venv</code> can be any name but for the purpose of simplicity, lets go with that. This folder is an isolated Python environment that separates the dependencies of our project from the system-wide Python installation.</p> <p>Now lets go on and activate the virtual environment using the following commands:</p> <p>On Linux or macOS:</p> <pre><code>source venv/bin/activate\n</code></pre> <p>On Windows:</p> <pre><code>venv\\Scripts\\activate\n</code></pre> <p>Once activated, your command line will indicate the active virtual environment:</p> <p>On Linux or macOS:</p> <pre><code>(venv) yourusername@yourmachine$\n</code></pre> <p>On Windows:</p> <pre><code>(venv) C:\\users\\YourUsername&gt;\n</code></pre>"},{"location":"services/gateway/chapter1/#2-directory-structure","title":"2. Directory Structure","text":"<p>At this point, your directory structure should look like this:</p> <pre><code>\u2514\u2500\u2500 venv\n\u2514\u2500\u2500 requiremnts.txt\n</code></pre>"},{"location":"services/gateway/chapter1/#3-installing-django","title":"3. Installing Django","text":"<p>Now, let us install Django within the virtual environment. We shall install Django using <code>pip</code> with the following command.</p> <pre><code>(venv) pip install \"django\"\n</code></pre>"},{"location":"services/gateway/chapter1/#4-freeze-dependencies","title":"4. Freeze Dependencies","text":"<p>Freeze the installed dependencies into a <code>requirements.txt</code> file to track the exact versions of our dependencies so that we can easily reproduce them in the future.</p> <pre><code>(env) pip freeze &gt; requirements.txt\n</code></pre>"},{"location":"services/gateway/chapter1/#5-confirm-the-installation","title":"5. Confirm the installation","text":"<p>Let us confirm our FastAPI installation by running the following command.</p> <pre><code>(env) python -m django --version\n4.2\n</code></pre> <p>This command will show us the version of the Django that we installed earlier on. </p> <p>If the version has been displayed, then we are sure that Django has been installed in our virtual environment.</p>"},{"location":"services/gateway/chapter1/#conclusion","title":"Conclusion","text":"<p>By following these steps, you have successfully created a project directory, set up a virtual environment, and installed Django, frozen the dependencies to reproduce the project in the future and you have verified your installation using the <code>python -m django --version</code> command. This structured approach ensures a clean and manageable development environment for our Django project. Next, we shall create the simpel auth project that we shall later on build on to create endpoints with django restframework.</p>"}]}